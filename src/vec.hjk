/// Given an inner type, generate a vector type and methods.
#MACRO VecOf (
    T,
    VecT,
    VecTWithCapacity,
    VecTNull,
    VecTFree,
    VecTGrow,
    VecTReserveOne,
    VecTReserveAt,
    VecTRemove,
) [

/// A vector, i.e. a growable array.
STRUCT VecT
    Elems : ^T, /// Pointer to array of elements.
    Length : UWORD, /// Number of elements in the list.
    Capacity : UWORD, /// Allocation size in elements.
END

/// Constructs and initializes a vector that can hold at least `cap` elements without reallocating.
FN VecTWithCapacity (
    IN cap : UWORD,
    IN vec : ^VecT,
)
    vec^.Length = 0
    vec^.Capacity = cap
    IF cap == 0 THEN
        vec^.Elems = NULLPTR
    ELSE
        bytes := cap * SIZEOF T
        ptr := AllocateMemory(bytes)
        Assert(CAST ptr TO UWORD, "out of memory", cap, bytes)
        vec^.Elems = ptr
    END
END

/// Constructs an empty vector.
FN VecTNull (
    IN vec : ^VecT,
)
    VecTWithCapacity(0, vec)
END

/// Frees a vector.
FN VecTFree (
    IN self : ^VecT,
)
    IF self^.Elems THEN
        FreeMemory(self^.Elems)
    END
END

/// Assures the vector has the capacity to store a given number of total elements.
FN VecTGrow (
    IN self : ^VecT,
    IN necessary_capacity : UWORD,
)
    IF self^.Capacity >= necessary_capacity THEN
        LEAVE
    END
    new_vec : VecT
    new_capacity := self^.Capacity / 2 * 3 + 8
    IF new_capacity < necessary_capacity THEN
        new_capacity = necessary_capacity
    END
    VecTWithCapacity(new_capacity, &new_vec)
    IF self^.Length THEN
        CopyMemoryBytes(self^.Elems, new_vec.Elems, self^.Length * SIZEOF T)
    END
    VecTFree(self)
    self^.Capacity = new_vec.Capacity
    self^.Elems = new_vec.Elems
END

/// Inserts a new element at the end of the vector, returning a pointer to the uninitialized element.
FN VecTReserveOne (
    IN self : ^VecT,
) : ^T
    VecTGrow(self, self^.Length + 1)
    self^.Length += 1
    RETURN &self^.Elems[self^.Length - 1]
END

/// Inserts `additional` new elements in the vector at position `index`, such that the new elements have indices [index, index + additional).
FN VecTReserveAt (
    IN self : ^VecT,
    IN index : UWORD,
    IN additional : UWORD,
) : ^T
    new_length := self^.Length + additional
    VecTGrow(self, new_length)
    i := self^.Length
    WHILE i >= index + 1 DO
        i -= 1
        CopyMemoryBytes(&self^.Elems[i], &self^.Elems[i + additional], SIZEOF T)
    END
    self^.Length = new_length
    RETURN &self^.Elems[index]
END

/// Removes the element at a given index, shifting later elements backwards by one.
FN VecTRemove (
    IN self : ^VecT,
    IN index : UWORD,
)
    self^.Length -= 1
    WHILE index < self^.Length DO
        // This is a type generic way to copy elements. We could probably do a bytewise copy instead.
        CopyMemoryBytes(&self^.Elems[index + 1], &self^.Elems[index], SIZEOF T)
        index += 1
    END
END
]

VecOf (
    UBYTE,
    VecUbyte,
    VecUbyteWithCapacity,
    VecUbyteNull,
    VecUbyteFree,
    VecUbyteGrow,
    VecUbyteReserveOne,
    VecUbyteReserveAt,
    VecUbyteRemove,
)
