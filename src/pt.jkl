/// The piece table, the fundamental data structure we use for storing and editing text. It consists of two parts: an append-only list of characters `Data`, and a list of slices into these characters `Pieces`. When editing text, characters are added to `Data` if necessary and we insert, modify, or delete a piece. Operations are `O(c + n)`, where `c` is the number of characters the operation inserts and `n` is the length of `Pieces`. The theory is that, even when a very large file is opened, a user will only edit that file in a limited number of locations, meaning untouched parts of the file can be manipulated as large, singular pieces.

/// A span of text indexing into `Pt.Data`.
STRUCT Piece
    /// The beginning index.
    Start : ULONG,
    /// The length in bytes.
    Length : ULONG,
END

VecOf (
    Piece,
    VecPiece,
    VecPieceWithCapacity,
    VecPieceNull,
    VecPieceFree,
    VecPieceGrow,
    VecPieceReserveOne,
    VecPieceReserveAt,
    VecPieceRemove,
)

/// The piece table, a simple text data structure suited for efficient, arbitrary edits across a file.
STRUCT Pt
    /// An append-only array of all characters added to the text buffer.
    Data : VecUbyte,

    /// Spans of `Data` that make up the current text buffer.
    Pieces : VecPiece,
END

/// Constructs an empty piece table.
FN PtNull (
    IN table : ^Pt,
)
    VecUbyteNull(&table^.Data)
    VecPieceNull(&table^.Pieces)
END

/// Constructs and initializes a piece table from a file.
FN PtInit (
    IN file : ^File,
    IN table : ^Pt,
)
    length := GetSize(file)
    // We could allocate extra space anticipating the user adding text to the file, but that's basically pointless. Under no circumstances is our bottleneck the resizing of the piece table vectors.
    VecUbyteWithCapacity(length, &table^.Data)
    Read(file, table^.Data.Elems, length)
    table^.Data.Length = length
    VecPieceWithCapacity(1, &table^.Pieces)
    table^.Pieces.Length = 1
    table^.Pieces.Elems^.Start = 0
    table^.Pieces.Elems^.Length = length
END

/// Frees a piece table.
FN PtFree (
    IN self : ^Pt,
)
    VecUbyteFree(&self^.Data)
    VecPieceFree(&self^.Pieces)
END

/// Returns the length in bytes of the text.
FN PtLength (
    IN self : ^Pt,
) : UWORD
    length := 0
    i := 0
    WHILE i < self^.Pieces.Length DO
        length += self^.Pieces.Elems[i].Length
        i += 1
    END
    RETURN length
END

/// Given a byte index, returns the index of the piece containing that byte and the byte offset within that piece. The index will be within [0, Pieces.Length] inclusive and offset will be within [0, Pieces[index].Length), unless index is equal to Pieces.Length in which case offset will be 0, this last case representing the position at the end of the text buffer.
FN PtSeek (
    IN self : ^Pt,
    IN seek_to : UWORD,
    OUT offset : UWORD,
) : UWORD
    i := 0
    seek_at := 0
    WHILE i < self^.Pieces.Length DO
        len := self^.Pieces.Elems[i].Length
        IF seek_at + len > seek_to THEN
            offset = seek_to - seek_at
            RETURN i
        END
        seek_at += len
        i += 1
    END
    // Reached end of file
    offset = 0
    RETURN i
END

/// Returns the character at a given byte index.
FN PtAt (
    IN self : ^Pt,
    IN seek_to : UWORD,
) : UBYTE
    offset : UWORD
    piece := PtSeek(self, seek_to, OUT offset)
    start := self^.Pieces.Elems[piece].Start
    RETURN self^.Data.Elems[start + offset]
END

/// Inserts a new character at an index, such that the index now points to that character.
FN PtInsert (
    IN self : ^Pt,
    IN position : UWORD,
    IN char : UBYTE,
)
    offset : UWORD
    piece_index := PtSeek(self, position, OUT offset)
    // Cursor is inserting a character either at the end of a piece or at the very beginning of the text.
    IF offset == 0 THEN
        is_at_end := 0
        IF piece_index > 0 THEN
            // TODO: Try to extend the span if the inserted character matches the next one in `Data`. This is an easy way for multiple cursors inserting characters to share a single data buffer allocation.
            original := &self^.Pieces.Elems[piece_index - 1]
            IF original^.Start + original^.Length == self^.Data.Length THEN
                is_at_end = 1
                original^.Length += 1 // Modify the previous piece to be one longer
            END
       END
       IF is_at_end == 0 THEN
            piece_new := VecPieceReserveAt(&self^.Pieces, piece_index, 1) // Allocate a new piece right *before* the current one
            piece_new^.Start = self^.Data.Length
            piece_new^.Length = 1
        END
        VecUbyteReserveOne(&self^.Data)^ = char
    // Cursor is inserting a character in the middle of a piece.
    ELSE
        piece_new := VecPieceReserveAt(&self^.Pieces, piece_index + 1, 2) // Allocate two pieces right *after* the current one; the first contains new data, the second the rest of the original piece
        piece_left := &self^.Pieces.Elems[piece_index]
        piece_right := &piece_new[1]
        piece_right^.Start = piece_left^.Start + offset
        piece_right^.Length = piece_left^.Length - offset
        piece_left^.Length = offset
        piece_new^.Start = self^.Data.Length
        piece_new^.Length = 1
        VecUbyteReserveOne(&self^.Data)^ = char
    END
END

/// Removes the character at some byte offset.
FN PtDelete (
    IN self : ^Pt,
    IN position : UWORD,
)
    offset : UWORD
    piece_index := PtSeek(self, position, OUT offset)
    Assert(piece_index < self^.Pieces.Length, "deleting character outside text buffer", piece_index, offset)
    piece := &self^.Pieces.Elems[piece_index]
    /// Cursor is deleting the only character of the piece: delete the piece.
    IF piece^.Length == 1 THEN
        VecPieceRemove(&self^.Pieces, piece_index)
    /// Cursor is deleting the leftmost character of the piece: shrink the piece from the left.
    ELSEIF offset == 0 THEN
        piece^.Start += 1
        piece^.Length -= 1
    /// Cursor is deleting the rightmost character of the piece: shrink the piece from the right.
    ELSEIF offset == piece^.Length - 1 THEN
        piece^.Length -= 1
    /// Cursor is deleting a character in the middle of the piece: split the piece in two, sans that character.
    ELSE
        new_piece := VecPieceReserveAt(&self^.Pieces, piece_index + 1, 1)
        piece = &self^.Pieces.Elems[piece_index]
        new_piece^.Start = piece^.Start + offset + 1
        new_piece^.Length = piece^.Length - offset - 1
        piece^.Length = offset
    END
END

/// Debug prints a string slice.
FN StrDebug (
    IN str : ^UBYTE,
    IN length : UWORD,
)
    RtlPrint("\"")
    i := 0
    WHILE i < length DO
        c := str[i]
        IF c == '"' THEN
            RtlPrint("\\\"")
        ELSEIF c == '\\' THEN
            RtlPrint("\\\\")
        ELSEIF ' ' <= c AND c <= '~' THEN
            RtlPrint("%c", c)
        ELSEIF c == '\n' THEN
            RtlPrint("\\n")
        ELSE
            RtlPrint("\\x%02x", c)
        END
        i += 1
    END
    RtlPrint("\"")
END

/// Debug prints the data of the piece table.
FN PtDebug (
    IN self : ^Pt,
)
    length := self^.Pieces.Length
    RtlPrint("[Pt, Data: %db, %d Pieces]\n", self^.Data.Length, length)
    i := 0
    WHILE i < length DO
        piece := &self^.Pieces.Elems[i]
        RtlPrint("%d - Start: %d Length: %d ", i, piece^.Start, piece^.Length)
        StrDebug(&self^.Data.Elems[piece^.Start], piece^.Length)
        RtlPrint("\n")
        i += 1
    END
END
